package parser

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/mabhi256/jdiag/internal/heap/model"
	"github.com/mabhi256/jdiag/internal/heap/registry"
)

/*
*	HProf binary format described here
*	https://github.com/openjdk/jdk/blob/master/src/hotspot/share/services/heapDumper.cpp
 */

// Parser represents the main HPROF file parser
type Parser struct {
	file       *os.File
	reader     *BinaryReader
	outputFile *os.File // For debugging output

	header    *model.HprofHeader
	stringReg *registry.StringRegistry
	classReg  *registry.ClassRegistry
	stackReg  *registry.StackRegistry
	// threadReg    *registry.ThreadRegistry
	rootReg      *registry.GCRootRegistry
	classDumpReg *registry.ClassDumpRegistry
	objectReg    *registry.InstanceRegistry
	arrayReg     *registry.ArrayRegistry

	// Statistics
	recordCount          int
	recordCountMap       map[model.HProfTagRecord]int
	heapDumpSegmentCount int
	heapDumpEnded        bool
}

// NewParser creates a new HPROF parser
func NewParser(filename string) (*Parser, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, fmt.Errorf("unable to open file: %w", err)
	}

	// Create debug output file (remove extension, add .debug)
	ext := filepath.Ext(filename)
	baseFilename := strings.TrimSuffix(filename, ext)
	debugFilename := baseFilename + ".debug"

	outputFile, err := os.Create(debugFilename)
	if err != nil {
		file.Close()
		return nil, fmt.Errorf("unable to create debug file: %w", err)
	}

	parser := &Parser{
		file:       file,
		reader:     NewBinaryReader(file),
		outputFile: outputFile,
		stringReg:  registry.NewStringRegistry(),
		classReg:   registry.NewClassRegistry(),
		stackReg:   registry.NewStackRegistry(),
		// threadReg:      registry.NewThreadRegistry(),
		rootReg:        registry.NewGCRootRegistry(),
		classDumpReg:   registry.NewClassDumpRegistry(),
		objectReg:      registry.NewInstanceRegistry(),
		arrayReg:       registry.NewArrayRegistry(),
		recordCountMap: make(map[model.HProfTagRecord]int),
	}

	return parser, nil
}

// Close closes the parser and its files
func (p *Parser) Close() error {
	var err error
	if p.file != nil {
		err = p.file.Close()
	}
	if p.outputFile != nil {
		p.outputFile.Close()
	}
	return err
}

// debugf writes debug information to our output file
func (p *Parser) debugf(format string, args ...interface{}) {
	fmt.Fprintf(p.outputFile, format, args...)
}

// parseHeader parses the HPROF file header
func (p *Parser) parseHeader() error {
	p.debugf("--- Parsing Header ---\n")
	p.debugf("Byte offset: %d\n", p.reader.BytesRead())

	header, err := ParseHeader(p.reader)
	if err != nil {
		return err
	}

	p.header = header

	p.debugf("Format: %s\n", header.Format)
	p.debugf("Identifier size: %d bytes\n", header.IdentifierSize)
	p.debugf("Raw timestamp: %d\n", header.Timestamp.UnixMilli())
	p.debugf("Timestamp: %s\n", header.Timestamp.Format("2006-01-02 15:04:05 UTC"))
	p.debugf("Header bytes read: %d\n", p.reader.BytesRead())
	p.debugf("Header parsed successfully!\n\n")

	return nil
}

// parseRecord parses a single record based on its type
func (p *Parser) parseRecord(record *model.HprofRecord) error {
	switch record.Type {
	case model.HPROF_UTF8:
		return p.parseUTF8Record(record.Length)

	case model.HPROF_LOAD_CLASS:
		return p.parseLoadClassRecord()

	case model.HPROF_UNLOAD_CLASS:
		return p.parseUnloadClassRecord()

	case model.HPROF_FRAME:
		return p.parseFrameRecord()

	case model.HPROF_TRACE:
		return p.parseTraceRecord()

	case model.HPROF_HEAP_DUMP, model.HPROF_HEAP_DUMP_SEGMENT:
		return p.parseHeapDumpSegmentRecord(record.Length)

	case model.HPROF_HEAP_DUMP_END:
		return p.parseHeapDumpEndRecord(record.Length)

	case model.HPROF_ALLOC_SITES:
		// HPROF_ALLOC_SITES: Generated only by deprecated -agentlib:hprof agent
		// Modern heap dumps (jcmd, -XX:+HeapDumpOnOutOfMemoryError) don't include this
		p.debugf("  Skipping deprecated ALLOC_SITES record (legacy HPROF agent)\n")
		return p.skipRecordData(record.Length)

	case model.HPROF_HEAP_SUMMARY:
		// HPROF_HEAP_SUMMARY: Legacy summary record, rarely used in modern dumps
		// Heap information is typically derived from heap dump segments
		p.debugf("  Skipping legacy HEAP_SUMMARY record (rarely used)\n")
		return p.skipRecordData(record.Length)

	case model.HPROF_START_THREAD, model.HPROF_END_THREAD:
		// HPROF_START_THREAD/END_THREAD: Rarely generated by modern JVMs
		// Thread information is typically captured in heap dump segments instead
		p.debugf("  Skipping rarely-used thread lifecycle record (%s)\n", record.Type)
		return p.skipRecordData(record.Length)

	case model.HPROF_CPU_SAMPLES:
		// HPROF_CPU_SAMPLES: Generated only by deprecated -agentlib:hprof agent
		// Modern profiling tools use different mechanisms for CPU sampling
		p.debugf("  Skipping deprecated CPU_SAMPLES record (legacy HPROF agent)\n")
		return p.skipRecordData(record.Length)

	case model.HPROF_CONTROL_SETTINGS:
		// HPROF_CONTROL_SETTINGS: Generated only by deprecated -agentlib:hprof agent
		// Modern heap dumps don't include profiler configuration settings
		p.debugf("  Skipping deprecated CONTROL_SETTINGS record (legacy HPROF agent)\n")
		return p.skipRecordData(record.Length)

	default:
		// For all other record types, skip the data for now
		return p.skipRecordData(record.Length)
	}
}

// parseUTF8Record parses a HPROF_UTF8 record
func (p *Parser) parseUTF8Record(length uint32) error {
	utf8Body, err := ParseUTF8(p.reader, length, p.stringReg)
	if err != nil {
		return fmt.Errorf("failed to parse UTF8 record: %w", err)
	}

	p.debugf("  String ID: 0x%x\n", uint64(utf8Body.StringID))
	p.debugf("  Text: \"%s\" (%d chars)\n", utf8Body.Text, len(utf8Body.Text))

	return nil
}

// parseLoadClassRecord parses a HPROF_LOAD_CLASS record
func (p *Parser) parseLoadClassRecord() error {
	loadClassBody, err := ParseLoadClass(p.reader, p.stringReg, p.classReg)
	if err != nil {
		return fmt.Errorf("failed to parse LOAD_CLASS record: %w", err)
	}

	className := p.stringReg.GetOrUnresolved(loadClassBody.ClassNameID)
	p.debugf("  Class Serial: %d\n", loadClassBody.ClassSerialNumber)
	p.debugf("  Object ID: 0x%x\n", uint64(loadClassBody.ObjectID))
	p.debugf("  Stack Trace Serial: %d\n", loadClassBody.StackTraceSerialNumber)
	p.debugf("  Class Name: \"%s\"\n", className)

	return nil
}

// parseUnloadClassRecord parses an UNLOAD_CLASS record
func (p *Parser) parseUnloadClassRecord() error {
	unloadClassBody, err := ParseUnloadClass(p.reader, p.classReg)
	if err != nil {
		return fmt.Errorf("failed to parse UNLOAD_CLASS record: %w", err)
	}

	p.debugf("  Class Serial: %d (unloaded)\n", unloadClassBody.ClassSerialNumber)

	return nil
}

func (p *Parser) parseFrameRecord() error {
	frameBody, err := ParseStackFrame(p.reader, p.stackReg)
	if err != nil {
		return fmt.Errorf("failed to parse FRAME record: %w", err)
	}

	p.debugf("  Frame ID: 0x%x\n", uint64(frameBody.StackFrameID))
	p.debugf("  Method: %s\n", p.stringReg.GetOrUnresolved(frameBody.MethodNameID))
	p.debugf("  Signature: %s\n", p.stringReg.GetOrUnresolved(frameBody.MethodSignatureID))
	p.debugf("  Source: %s\n", p.stringReg.GetOrUnresolved(frameBody.SourceFileNameID))
	p.debugf("  Class Serial: %d\n", frameBody.ClassSerialNumber)
	p.debugf("  Line: %d\n", frameBody.LineNumber)

	return nil
}

func (p *Parser) parseTraceRecord() error {
	traceBody, err := ParseStackTrace(p.reader, p.stackReg)
	if err != nil {
		return fmt.Errorf("failed to parse TRACE record: %w", err)
	}

	p.debugf("  Trace Serial: %d\n", traceBody.StackTraceSerialNumber)
	p.debugf("  Thread Serial: %d\n", traceBody.ThreadSerialNumber)
	p.debugf("  Frame Count: %d\n", traceBody.NumFrames)
	p.debugf("  Frame IDs: ")
	for i, frameID := range traceBody.StackFrameIDs {
		if i > 0 {
			p.debugf(", ")
		}
		p.debugf("0x%x", uint64(frameID))
	}
	p.debugf("\n")

	return nil
}

func (p *Parser) parseHeapDumpSegmentRecord(length uint32) error {
	p.heapDumpSegmentCount++

	subRecordCount, subRecordCountMap, err := ParseHeapDumpSegment(p.reader, length,
		p.rootReg, p.classDumpReg, p.objectReg, p.stringReg, p.arrayReg)
	if err != nil {
		return fmt.Errorf("failed to parse HEAP_DUMP_SEGMENT record: %w", err)
	}

	p.debugf("  Segment #%d: %d bytes, %d sub-records\n",
		p.heapDumpSegmentCount, length, subRecordCount)

	p.debugf("  Sub-record breakdown:\n")
	for subRecordType, count := range subRecordCountMap {
		p.debugf("    %s: %d\n", subRecordType, count)
	}

	return nil
}

func (p *Parser) parseHeapDumpEndRecord(length uint32) error {
	err := ParseHeapDumpEnd(length)
	if err != nil {
		return fmt.Errorf("failed to parse HEAP_DUMP_END record: %w", err)
	}

	p.heapDumpEnded = true
	p.debugf("  Heap dump sequence completed\n")

	return nil
}

// skipRecordData skips record data that we don't parse yet
func (p *Parser) skipRecordData(length uint32) error {
	err := p.reader.Skip(int(length))
	if err != nil {
		return fmt.Errorf("failed to skip %d bytes: %w", length, err)
	}
	p.debugf("  Skipped %d bytes of record data\n", length)
	return nil
}

// parseRecords parses all records in the file
func (p *Parser) parseRecords() error {
	p.debugf("--- Parsing Records ---\n")

	for {
		cursor := p.reader.BytesRead()

		record, err := p.reader.ReadRecordHeader()
		if err == io.EOF {
			p.debugf("Reached EOF. Parsed %d records.\n", p.recordCount)
			break
		}
		if err != nil {
			return fmt.Errorf("cursor %d - failed to read record header: %w", p.recordCount, err)
		}

		p.recordCount++
		p.recordCountMap[record.Type]++

		p.debugf("Record #%d at offset %d:\n", p.recordCount, cursor)
		p.debugf("  Type: %s (0x%02x)\n", record.Type, record.Type)
		p.debugf("  Time offset: %d ms\n", record.TimeOffset)
		p.debugf("  Length: %d bytes\n", record.Length)

		newCursorExpected := cursor + 9 + int64(record.Length)

		p.parseRecord(record)

		if p.reader.BytesRead() != newCursorExpected {
			return fmt.Errorf(
				"position mismatch after %s record: expected %d, got %d",
				record.Type, newCursorExpected, p.reader.BytesRead())
		}

		p.debugf("  Processed successfully, now at offset %d\n\n", p.reader.BytesRead())
	}

	return nil
}

// printSummary prints a summary of parsing results
func (p *Parser) printSummary() {
	p.debugf("--- Record Summary ---\n")
	p.debugf("Total records: %d\n", p.recordCount)
	p.debugf("Record type breakdown:\n")
	for recordType, count := range p.recordCountMap {
		p.debugf("  %s: %d\n", recordType, count)
	}
	p.debugf("Total bytes processed: %d\n", p.reader.BytesRead())

	// Show some example strings
	p.debugf("\nSample strings from table:\n")
	stringSampleCount := 0
	maxStringSamples := 10
	for id, text := range p.stringReg.GetAll() {
		if stringSampleCount >= maxStringSamples {
			break
		}
		if len(text) > 50 {
			p.debugf("  0x%x: \"%.50s...\" (%d chars)\n", uint64(id), text, len(text))
		} else {
			p.debugf("  0x%x: \"%s\"\n", uint64(id), text)
		}
		stringSampleCount++
	}

	p.debugf("Total strings in table: %d\n", p.stringReg.Count())

	p.debugf("\nSample loaded classes:\n")
	loadedClasses := p.classReg.GetLoadedClasses()
	maxClassSamples := 15
	for i, classInfo := range loadedClasses {
		if i >= maxClassSamples {
			p.debugf("  ... and %d more classes\n", len(loadedClasses)-maxClassSamples)
			break
		}
		p.debugf("  %d. %s (id: 0x%x)\n",
			classInfo.LoadClassBody.ClassSerialNumber,
			classInfo.ClassName,
			uint64(classInfo.LoadClassBody.ObjectID))
	}

	p.debugf("\nSample frames from registry:\n")
	frameSampleCount := 0
	maxFrameSamples := 5
	for frameID, frame := range p.stackReg.GetAllFrames() {
		if frameSampleCount >= maxFrameSamples {
			break
		}

		methodName := p.stringReg.GetOrUnresolved(frame.MethodNameID)
		sourceFile := p.stringReg.GetOrUnresolved(frame.SourceFileNameID)

		p.debugf("  Frame 0x%x: %s (%s:%d)\n",
			uint64(frameID), methodName, sourceFile, frame.LineNumber)
		frameSampleCount++
	}

	p.debugf("\nSample traces from registry:\n")
	traceSampleCount := 0
	maxTraceSamples := 5
	for frameID, frame := range p.stackReg.GetAllFrames() {
		if traceSampleCount >= maxTraceSamples {
			break
		}

		methodName := p.stringReg.GetOrUnresolved(frame.MethodNameID)
		sourceFile := p.stringReg.GetOrUnresolved(frame.SourceFileNameID)

		p.debugf("  Frame 0x%x: %s (%s:%d)\n",
			uint64(frameID), methodName, sourceFile, frame.LineNumber)
		traceSampleCount++
	}

	p.debugf("\n--- GC Root Summary ---\n")
	p.debugf("Total GC roots: %d\n", p.rootReg.GetTotalRoots())

	rootTypeCounts := p.rootReg.GetRootTypeCounts()
	p.debugf("GC root type breakdown:\n")
	for rootType, count := range rootTypeCounts {
		p.debugf("  %s: %d\n", rootType, count)
	}

	// Show thread object information
	threadObjects := p.rootReg.GetThreadObjectRoots()
	if len(threadObjects) > 0 {
		p.debugf("\nThread objects identified:\n")
		maxThreadSamples := 10
		for i, threadObj := range threadObjects {
			if i >= maxThreadSamples {
				p.debugf("  ... and %d more threads\n", len(threadObjects)-maxThreadSamples)
				break
			}

			// Try to get the stack trace for this thread
			if trace, exists := p.stackReg.GetTrace(threadObj.StackTraceSerialNumber); exists {
				p.debugf("  Thread %d: Object ID 0x%x, Stack trace %d (%d frames)\n",
					threadObj.ThreadSerialNumber,
					uint64(threadObj.ThreadObjectID),
					threadObj.StackTraceSerialNumber,
					trace.NumFrames)
			} else {
				p.debugf("  Thread %d: Object ID 0x%x, Stack trace %d (not found)\n",
					threadObj.ThreadSerialNumber,
					uint64(threadObj.ThreadObjectID),
					threadObj.StackTraceSerialNumber)
			}
		}
	}

	// Show thread stack root analysis
	threadSerials := p.rootReg.GetAllThreadSerials()
	if len(threadSerials) > 0 {
		p.debugf("\nThread stack memory analysis:\n")
		maxThreadStackSamples := 5
		for i, threadSerial := range threadSerials {
			if i >= maxThreadStackSamples {
				break
			}

			stackRoots := p.rootReg.GetThreadStackRoots(threadSerial)
			p.debugf("  Thread %d: %d stack root objects\n", threadSerial, len(stackRoots))
		}
	}

	p.debugf("\n--- Class Dump Summary ---\n")
	p.debugf("Total class dumps: %d\n", p.classDumpReg.GetCount())

	// Show sample class dumps
	allClassDumps := p.classDumpReg.GetAllClassDumps()
	if len(allClassDumps) > 0 {
		p.debugf("\nSample class dumps:\n")
		maxClassDumpSamples := 10
		count := 0
		for classID, classDump := range allClassDumps {
			if count >= maxClassDumpSamples {
				p.debugf("  ... and %d more classes\n", len(allClassDumps)-maxClassDumpSamples)
				break
			}

			p.debugf("  Class 0x%x: Instance size %d bytes, %d static fields, %d instance fields\n",
				uint64(classID),
				classDump.InstanceSize,
				len(classDump.StaticFields),
				len(classDump.InstanceFields))
			count++
		}
	}

	// Phase 9: Object Instance Summary
	p.debugf("\n--- Object Instance Summary ---\n")
	p.debugf("Total object instances: %d\n", p.objectReg.GetCount())
	p.debugf("Total instance memory: %d bytes (%.2f MB)\n",
		p.objectReg.GetTotalSize(),
		float64(p.objectReg.GetTotalSize())/(1024*1024))

	// Show instance counts by class
	classCounts := p.objectReg.GetInstanceClassCounts()
	if len(classCounts) > 0 {
		p.debugf("\nTop classes by instance count:\n")
		// Simple display of first few classes
		count := 0
		maxClassInstanceSamples := 10
		for classID, instanceCount := range classCounts {
			if count >= maxClassInstanceSamples {
				p.debugf("  ... and %d more classes\n", len(classCounts)-maxClassInstanceSamples)
				break
			}
			p.debugf("  Class 0x%x: %d instances\n", uint64(classID), instanceCount)
			count++
		}
	}

	// // Show Thread instances (Phase 9.4)
	// threadInstanceCount := p.objectReg.GetThreadCount()
	// if threadInstanceCount > 0 {
	// 	p.debugf("\nThread Object Instances: %d\n", threadInstanceCount)
	// 	threadInstances := p.objectReg.GetAllThreadInstances()
	// 	maxThreadInstanceSamples := 5
	// 	count := 0
	// 	for objectID, threadData := range threadInstances {
	// 		if count >= maxThreadInstanceSamples {
	// 			p.debugf("  ... and %d more thread instances\n", len(threadInstances)-maxThreadInstanceSamples)
	// 			break
	// 		}

	// 		name := threadData.Name
	// 		if name == "" {
	// 			name = "<unknown>"
	// 		}
	// 		p.debugf("  Thread 0x%x (TID: %d): Name=\"%s\", Priority=%d, Daemon=%t\n",
	// 			uint64(objectID), threadData.ThreadID, name, threadData.Priority, threadData.Daemon)
	// 		count++
	// 	}
	// }

	// Show object statistics
	stats := p.objectReg.Statistics()
	if avgSize, ok := stats["average_size"].(float64); ok {
		p.debugf("\nObject Statistics:\n")
		p.debugf("  Average object size: %.2f bytes\n", avgSize)
		if uniqueClasses, ok := stats["unique_classes"].(int); ok {
			p.debugf("  Unique classes with instances: %d\n", uniqueClasses)
		}
	}

	p.debugf("\n--- Array Summary ---\n")
	p.debugf("Total arrays: %d\n", p.arrayReg.GetCount())
	p.debugf("Object arrays: %d\n", p.arrayReg.GetObjectArrayCount())
	p.debugf("Primitive arrays: %d\n", p.arrayReg.GetPrimitiveArrayCount())
	p.debugf("Total array elements: %d\n", p.arrayReg.GetTotalElements())
	p.debugf("Total array memory: %d bytes (%.2f MB)\n",
		p.arrayReg.GetTotalSize(),
		float64(p.arrayReg.GetTotalSize())/(1024*1024))

	// Show largest arrays
	largestArrays := p.arrayReg.GetLargestArrays(5)
	if len(largestArrays) > 0 {
		p.debugf("\nLargest arrays:\n")
		for i, array := range largestArrays {
			p.debugf("  %d. Array 0x%x: %d elements (%s - %s)\n",
				i+1, uint64(array.ObjectID), array.Size, array.Type, array.ElementType)
		}
	}

	// Show array statistics
	arrayStats := p.arrayReg.Statistics()
	if avgObjSize, ok := arrayStats["avg_object_array_size"].(float64); ok {
		p.debugf("\nArray Statistics:\n")
		p.debugf("  Average object array size: %.2f elements\n", avgObjSize)
		if avgPrimSize, ok := arrayStats["avg_primitive_array_size"].(float64); ok {
			p.debugf("  Average primitive array size: %.2f elements\n", avgPrimSize)
		}
	}
}

// ParseHprof parses an HPROF file completely
// Each HPROF file follows this structure:
// [Header]
// [Record 1]
// [Record 2]
// ...
// [Record N]
func (p *Parser) ParseHprof() error {
	defer p.Close()

	p.debugf("üîç Starting HPROF analysis of: %s\n", p.file.Name())

	if err := p.parseHeader(); err != nil {
		return err
	}

	if err := p.parseRecords(); err != nil {
		return err
	}

	p.printSummary()
	p.debugf("--- PARSING COMPLETE ---\n")

	return nil
}

// GetHeader returns the parsed header
func (p *Parser) GetHeader() *model.HprofHeader {
	return p.header
}

// GetStringRegistry returns the string registry
func (p *Parser) GetStringRegistry() *registry.StringRegistry {
	return p.stringReg
}

// GetObjectRegistry returns the object registry
func (p *Parser) GetObjectRegistry() *registry.InstanceRegistry {
	return p.objectReg
}

// GetArrayRegistry returns the array registry
func (p *Parser) GetArrayRegistry() *registry.ArrayRegistry {
	return p.arrayReg
}
